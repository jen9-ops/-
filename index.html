<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Геометрія Війни [v4.6 - Smart AI & Live Coords]</title>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js",
                "three/examples/jsm/renderers/CSS2DRenderer": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/renderers/CSS2DRenderer.js"
            }
        }
    </script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        :root {
            --primary-color: #7EC8E3; --secondary-color: #000C66; --accent-color: #FFFFFF;
            --danger-color: #ff3366; --success-color: #33ff99; --warning-color: #ffcc00;
            --bg-color: #050A30; --bg-panel-color: rgba(0, 12, 102, 0.4);
            --text-color: #E0E0E0; --border-color: rgba(126, 200, 227, 0.2);
            --font-family: 'Inter', sans-serif; --font-mono: 'Roboto Mono', monospace;
            --base-font-size: 16px;
        }
        html { font-size: var(--base-font-size); scroll-behavior: smooth; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: var(--font-family); display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        #game-container { display: flex; flex-direction: row; background-color: #000; width: 100vw; height: 100vh; position: relative; box-sizing: border-box; overflow: hidden; }
        #main-view { flex-grow: 1; position: relative; height: 100%; width: 100%; }
        #map-container, #viewer, .external-map-container, #labels-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #labels-container { pointer-events: none; z-index: 3; }
        #map-container { z-index: 1; opacity: 0; visibility: hidden; transition: opacity 0.3s ease-in-out; }
        #map-container.visible { opacity: 1; visibility: visible; }
        #viewer { z-index: 2; cursor: crosshair; }
        #viewer:active { cursor: grabbing; }
        #viewer canvas { display: block; }
        .external-map-container { z-index: 3; display: none; }
        .external-map-container iframe { width: 100%; height: 100%; border: 0; }
        #viewer.overlay-active { z-index: 4; pointer-events: none; }
        #viewer.overlay-active canvas { pointer-events: auto; }
        #top-right-controls { position: absolute; top: 1rem; right: 1rem; z-index: 5; display: flex; flex-direction: column; align-items: flex-end; gap: 0.5rem; }
        #top-center-hud { position: absolute; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 5; display: flex; flex-direction: column; align-items: center; gap: 0.5rem; pointer-events: none; color: var(--primary-color); background-color: rgba(0,0,0,0.5); padding: 0.25rem 0.75rem; border-radius: 4px; font-family: var(--font-mono); font-size: 0.9rem; }
        .hud-row { display: flex; gap: 1.5rem; }
        #ui-panel { width: clamp(340px, 25vw, 450px); height: 100%; background-color: var(--bg-panel-color); backdrop-filter: blur(12px); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; position: absolute; top: 0; left: 0; z-index: 4; transform: translateX(-100%); transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); box-shadow: 10px 0 30px rgba(0,0,0,0.5); }
        #ui-panel.visible { transform: translateX(0); }
        .ui-header { padding: 1rem 1.25rem; border-bottom: 1px solid var(--border-color); }
        .ui-header h2 { margin: 0; color: var(--primary-color); font-size: 1.5rem; }
        .ui-content { padding: 1.25rem; overflow-y: auto; display: flex; flex-direction: column; gap: 1.25rem; flex-grow: 1; }
        .ui-section { background: rgba(0,0,0,0.2); border: 1px solid var(--border-color); padding: 1rem; border-radius: 8px; }
        .ui-section h3 { color: var(--primary-color); margin: 0 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); font-size: 1.1rem; }
        .control-grid { display: grid; grid-template-columns: 120px 1fr; gap: 0.75rem; align-items: center; }
        label { text-align: right; font-size: 0.95rem; color: #ccc; }
        select, input { background-color: rgba(0,0,0,0.4); color: var(--text-color); border: 1px solid var(--border-color); font-family: inherit; padding: 0.5rem; border-radius: 5px; width: 100%; box-sizing: border-box; font-size: 0.9rem; transition: all 0.2s ease; }
        select:focus, input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 10px rgba(126, 200, 227, 0.3); }
        button { background-color: var(--secondary-color); color: var(--accent-color); border: 1px solid var(--primary-color); padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer; transition: all 0.2s ease; font-weight: 500; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        button svg { width: 18px; height: 18px; }
        button:hover:not(:disabled) { background-color: var(--primary-color); color: var(--secondary-color); }
        button:disabled { background-color: #333; border-color: #555; color: #888; cursor: not-allowed; }
        #fire-button { background-color: var(--success-color); border-color: var(--success-color); color: #000; }
        .info-display, .report-display { text-align: left; font-size: 1rem; color: var(--accent-color); padding: 0.5rem; background-color: rgba(0,0,0,0.2); border-radius: 3px; border: 1px solid #444; font-family: var(--font-mono); }
        .action-buttons { display: grid; grid-template-columns: 1fr; gap: 0.75rem; }
        #toggle-ui-button { position: absolute; top: 1rem; left: 1rem; z-index: 6; width: 40px; height: 40px; background-color: var(--bg-panel-color); border: 1px solid var(--border-color); color: var(--primary-color); font-size: 1.2rem; display: flex; justify-content: center; align-items: center; border-radius: 5px; cursor: pointer; transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        #ui-panel.visible ~ #toggle-ui-button { left: calc(clamp(340px, 25vw, 450px) + 1rem); }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px); z-index: 100; display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease-in-out; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: var(--bg-color); padding: 1.5rem; border: 2px solid var(--primary-color); border-radius: 8px; width: 90%; max-width: 600px; box-shadow: 0 0 25px rgba(126, 200, 227, 0.3); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--primary-color); padding-bottom: 1rem; margin-bottom: 1rem; }
        .modal-header h2 { margin: 0; color: var(--primary-color); font-size: 1.5rem; }
        .modal-close-button { background: none; border: none; color: var(--text-color); font-size: 1.5rem; cursor: pointer; }
        .modal-body { max-height: 70vh; overflow-y: auto; }
        #triangulation-rays-list { list-style: none; padding: 0; margin: 1rem 0; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 0.5rem;}
        .triangulation-ray-item { display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0.5rem; font-family: var(--font-mono); font-size: 0.9rem; }
        .triangulation-ray-item button { padding: 0.1rem 0.4rem; font-size: 0.8rem; background-color: var(--danger-color); border: none;}
        #impact-info-display { position: absolute; display: none; background-color: rgba(0,0,0,0.7); color: white; padding: 8px; border-radius: 5px; font-family: var(--font-mono); pointer-events: none; transform: translate(-50%, -120%); z-index: 10; border: 1px solid var(--primary-color); }
        .trajectory-label { background-color: rgba(0, 0, 0, 0.6); color: #fff; padding: 4px 8px; border-radius: 4px; font-family: var(--font-mono); font-size: 14px; text-shadow: 1px 1px 2px black; white-space: nowrap; }
        @media (max-width: 768px) {
            #ui-panel { width: 100%; height: 60%; top: auto; bottom: 0; left: 0; border-right: none; border-top: 2px solid var(--primary-color); transform: translateY(100%); }
            #ui-panel.visible { transform: translateY(0); }
            #toggle-ui-button { top: auto; bottom: 1rem; left: 1rem; }
            #ui-panel.visible ~ #toggle-ui-button { left: 1rem; transform: translateY(-60vh); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="main-view">
            <div id="labels-container"></div>
            <div id="top-center-hud">
                <div id="mouse-coords-display">Lat/Lon: ---</div>
                <div class="hud-row">
                    <div id="fps-counter">FPS: 0</div>
                    <div id="k-display">k: 1.000</div>
                    <div id="tof-display">ToF: ---</div>
                    <div id="range-hud-display">Дальність: ---</div>
                    <div id="direct-range-hud-display">Пряма: ---</div>
                </div>
            </div>
            <div id="top-right-controls">
                <button id="simulate-enemy-fire-button" title="Зімітувати ворожий постріл (за даними звіту)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>
                </button>
                <button id="open-triangulation-button" title="Тріангуляція">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>
                </button>
                 <button id="open-prediction-modal-button" title="Прогноз подій">
                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>
                </button>
                <button id="extra-info-button" title="Додатково">
                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.44,0.17-0.48,0.41L9.2,5.7c-0.59,0.24-1.13,0.57-1.62,0.94l-2.39-0.96c-0.22-0.08-0.47,0-0.59,0.22L2.69,9.22 c-0.11,0.2-0.06,0.47,0.12,0.61l2.03,1.58C4.78,11.69,4.76,12,4.76,12s0.02,0.31,0.07,0.63l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17-0.48,0.41l0.36-2.54c0.59-0.24,1.13-0.57,1.62,0.94l2.39,0.96 c0.22,0.08,0.47,0-0.59,0.22l1.92-3.32c0.11-0.2,0.06-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
                </button>
            </div>
            <div id="map-container"></div>
            <div id="viewer"></div>
             <div id="deepstate-map-wrapper" class="external-map-container">
                 <iframe id="deepstate-iframe" src="https://deepstatemap.live/#7/50.3276700/32.1789551" title="DeepState Map"></iframe>
            </div>
        </div>
        
        <button id="toggle-ui-button">☰</button>

        <div id="ui-panel">
            <div class="ui-header">
                <h2>ГЕОМЕТРІЯ 3D</h2>
            </div>
            <div class="ui-content">
                <div class="ui-section">
                    <h3>ЦІЛЬ ПО КООРДИНАТАМ</h3>
                    <div class="control-grid">
                        <label for="target-lat-input">Lat:</label>
                        <input type="number" id="target-lat-input" placeholder="50.4501" step="0.00001">
                        <label for="target-lon-input">Lon:</label>
                        <input type="number" id="target-lon-input" placeholder="30.5234" step="0.00001">
                    </div>
                    <div class="action-buttons" style="margin-top: 1rem;">
                        <button id="calculate-target-solution-button">РОЗРАХУВАТИ</button>
                    </div>
                </div>

                <div class="ui-section">
                    <h3>ПАРАМЕТРИ СТРІЛЬБИ</h3>
                    <div class="control-grid">
                        <label for="position-select">Позиція:</label>
                        <select id="position-select"></select>
                        <label for="charge-select">Заряд:</label>
                        <select id="charge-select">
                            <option value="0">№0 (Далекобійний)</option>
                            <option value="1">№1</option>
                            <option value="2" selected>№2</option>
                            <option value="3">№3</option>
                        </select>
                        <label for="charge-temp-input">T° заряду (°C):</label>
                        <input type="number" id="charge-temp-input" value="15" step="1">
                        <label for="angle-input">Кут (верт.):</label>
                        <input type="number" id="angle-input" value="60" min="45" max="85" step="0.1">
                        <label for="h-correction-input">Азимут:</label>
                        <input type="number" id="h-correction-input" value="0" step="1">
                    </div>
                </div>

                <div class="ui-section">
                    <h3>ДІЇ</h3>
                    <div class="action-buttons">
                        <button id="fire-button">ВОГОНЬ!</button>
                        <button id="open-calibration-button">КАЛІБРУВАННЯ</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="modal-overlay" class="modal-overlay">
        <div class="modal-content">
             <div class="modal-header">
                <h2>Додатково</h2>
                <button class="modal-close-button">&times;</button>
            </div>
            <div class="modal-body">
                <p><strong>Версія:</strong> <span id="game-version"></span></p>
                <div class="ui-section">
                    <h3>НАЛАШТУВАННЯ ВИГЛЯДУ</h3>
                    <div class="control-grid">
                        <label for="trajectory-checkbox">Траєкторія:</label>
                        <input type="checkbox" id="trajectory-checkbox" checked>
                        <label for="show-map-checkbox">2D Карта:</label>
                        <input type="checkbox" id="show-map-checkbox">
                        <label for="show-deepstate-checkbox">DeepState:</label>
                        <input type="checkbox" id="show-deepstate-checkbox">
                    </div>
                     <div class="action-buttons" style="margin-top: 1rem;">
                        <button id="reset-deformation-button">Скинути деформації</button>
                    </div>
                </div>
                <div class="ui-section">
                    <h3>ПОГОДА ТА GPS</h3>
                     <div class="control-grid">
                         <label>Температура:</label><div id="temperature-display" class="info-display">-- °C</div>
                         <label>Щільність повітря:</label><div id="air-density-display" class="info-display">-- кг/м³</div>
                         <label>Вітер:</label><div id="wind-display" class="info-display">-- м/с (---)</div>
                    </div>
                    <div class="action-buttons" style="margin-top: 1rem;">
                        <button id="locate-and-weather-button">
                             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                            Позиція & Погода
                        </button>
                    </div>
                </div>
                <div class="ui-section">
                    <h3>ЗБЕРЕЖЕННЯ ДАНИХ</h3>
                    <div class="action-buttons" style="grid-template-columns: 1fr 1fr;">
                         <button id="save-state-button">Зберегти стан</button>
                         <button id="clear-state-button" style="background-color: var(--danger-color); border-color: var(--danger-color); color: #000;">Очистити</button>
                    </div>
                </div>
                 <div class="action-buttons" style="margin-top: 1.5rem;">
                     <button id="create-snapshot-button">Знімок карти на сцену</button>
                     <button id="clear-snapshot-button">Видалити знімок</button>
                </div>
            </div>
        </div>
    </div>

    <div id="calibration-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Калібрування по точці влучання</h2>
                <button class="modal-close-button">&times;</button>
            </div>
            <div class="modal-body">
                <p>Введіть координати фактичного місця падіння снаряда для автоматичного коригування балістичного коефіцієнта (k).</p>
                <div class="ui-section">
                    <h3>Координати падіння</h3>
                    <div class="control-grid">
                        <label for="impact-lat-input">Lat:</label>
                        <input type="number" id="impact-lat-input" placeholder="50.4505" step="0.00001">
                        <label for="impact-lon-input">Lon:</label>
                        <input type="number" id="impact-lon-input" placeholder="30.5230" step="0.00001">
                    </div>
                </div>
                <div class="action-buttons" style="margin-top: 1rem;">
                    <button id="calibrate-k-button">СКОРИГУВАТИ 'k'</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="triangulation-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Тріангуляція (МНК)</h2>
                <button class="modal-close-button">&times;</button>
            </div>
            <div class="modal-body">
                <p>Додайте як мінімум два промені (точка спостереження + азимут), щоб розрахувати найбільш імовірну точку їхнього перетину.</p>
                <div class="ui-section">
                     <div class="control-grid">
                         <label for="ray-lat-input">Lat:</label>
                        <input type="number" id="ray-lat-input" placeholder="50.45" step="0.00001">
                         <label for="ray-lon-input">Lon:</label>
                        <input type="number" id="ray-lon-input" placeholder="30.52" step="0.00001">
                         <label for="ray-azimuth-input">Азимут (°):</label>
                        <input type="number" id="ray-azimuth-input" placeholder="45" step="0.1">
                    </div>
                    <div class="action-buttons" style="margin-top: 1rem;">
                        <button id="add-triangulation-ray-button">Додати промінь</button>
                    </div>
                </div>
                <ul id="triangulation-rays-list"></ul>
                <div class="action-buttons" style="margin-top: 1rem; grid-template-columns: 1fr 1fr;">
                    <button id="calculate-intersection-button" disabled>Знайти перетин</button>
                    <button id="aim-at-intersection-button" disabled>НАВЕСТИСЬ</button>
                </div>
            </div>
        </div>
    </div>

     <div id="prediction-modal-overlay" class="modal-overlay">
         <div class="modal-content">
             <div class="modal-header">
                 <h2>Прогноз подій («Показати дуги»)</h2>
                 <button class="modal-close-button">&times;</button>
            </div>
             <div class="modal-body">
                 <p>Відображення всіх можливих траєкторій (віяло висот) від активної позиції до найближчої цілі для різних зарядів.</p>
                 <div class="action-buttons" style="margin-top: 1rem;">
                      <button id="show-all-trajectories-button">Показати дуги</button>
                      <button id="clear-all-trajectories-button">Сховати дуги</button>
                </div>
            </div>
        </div>
    </div>

    <div id="enemy-report-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Аналіз Ворожого Пострілу</h2>
                <button class="modal-close-button">&times;</button>
            </div>
            <div class="modal-body">
                <div class="ui-section">
                    <h3>Результати</h3>
                    <div class="control-grid">
                        <label>Точка старту (Lat, Lon):</label><div id="report-launch-coords" class="report-display">--</div>
                        <label>Точка падіння (Lat, Lon):</label><div id="report-impact-coords" class="report-display">--</div>
                        <label>Дистанція по прямій:</label><div id="report-direct-distance" class="report-display">-- м</div>
                        <label>Довжина траєкторії:</label><div id="report-ballistic-range" class="report-display">-- м</div>
                        <label>Час польоту (ToF):</label><div id="report-tof" class="report-display">-- с</div>
                    </div>
                </div>
                <div class="ui-section">
                    <h3>Параметри розрахунку</h3>
                    <div class="control-grid">
                         <label>Поч. швидкість:</label><div id="report-param-velocity" class="report-display">--</div>
                         <label>Маса снаряду:</label><div id="report-param-mass" class="report-display">--</div>
                         <label>Гравітація:</label><div id="report-param-gravity" class="report-display">--</div>
                         <label>Щільність повітря:</label><div id="report-param-density" class="report-display">--</div>
                         <label>Вітер (швидк, напрям):</label><div id="report-param-wind" class="report-display">--</div>
                         <label>Балліст. коеф. (k):</label><div id="report-param-k" class="report-display">--</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="impact-info-display"></div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
        import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';
        
        const eventLogData = {
          "shift": "Ворона",
          "position": { "name": "С", "location": { "lat": 49.2142592, "lon": 37.2703232 } },
          "events": [
            { "name": "Минометный обстрел 82мм", "timestamp": "2025-09-26T16:40:26.950Z", "azimuth": "110", "distance": "2895" },
            { "name": "Минометный обстрел 120мм", "timestamp": "2025-09-26T17:17:20.508Z", "azimuth": "100", "distance": "2785" },
          ]
        };

        const CONFIG = {
            GRAVITY: 9.80665,
            BALLISTIC_K: 1.0, 
            VERSION: "4.6", // --- VERSION UPDATED ---
            HIT_RADIUS: 50,
            STORAGE_KEY: 'geometryWarfareState_v3',
            STANDARD_TEMP_C: 15, 
            TEMP_VELOCITY_COEFFICIENT: 0.0005,
        };
        
        const MORTAR_TABLES = {
            '120mm_HE': {
                mass: 15.8, caliber: 0.120, Cd: 0.25,
                charges: { '0': 345, '1': 147, '2': 208, '3': 295, }
            }
        };

        const gameState = {
            playerPositions: {},
            weather: { tempC: 15, windSpeed: 0, windDirection: 0, airDensity: 1.225 },
            activePlayerPositionName: null,
            currentCoords: null, 
            lastShot: { startPoint: null, intendedEndPoint: null },
            triangulationRays: [],
            lastTriangulationResult: null,
            mapLayers: { trajectory: null, impacts: L.layerGroup() },
            gpsMarker: { three: null, map: null },
            lastImpactPointForInfo: null,
        };

        const ui = {};
        let activeExplosions = [];

        const three = {
            scene: new THREE.Scene(), camera: null, renderer: null, controls: null, labelRenderer: null,
            gameGroup: new THREE.Group(), effectsGroup: new THREE.Group(),
            triangulationGroup: new THREE.Group(), groundPlane: null, 
            initialGroundVertices: null,
            enemyTrajectoryGroup: new THREE.Group(),
            labelsGroup: new THREE.Group(),
        };
        
        let map;
        let trajectoryVisualsGroup = null;
        let triangulationIntersectionMarker = null;
        let lastTime = performance.now(), frameCount = 0;

        function init() {
            document.querySelectorAll('[id]').forEach(el => {
                const camelCaseId = el.id.replace(/-([a-z])/g, g => g[1].toUpperCase());
                ui[camelCaseId] = el;
            });
            
            initThree();
            initMap();
            initGameLogic();
            initEventListeners();
            loadState(); 
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();
            animate();
            logMessage(`Система ініціалізована. Версія ${CONFIG.VERSION}`, "system");
            ui.gameVersion.textContent = CONFIG.VERSION;
            updateWeatherDisplays();
        }

        function initThree() {
            three.camera = new THREE.PerspectiveCamera(60, ui.viewer.clientWidth / ui.viewer.clientHeight, 1, 50000);
            three.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            three.renderer.setSize(ui.viewer.clientWidth, ui.viewer.clientHeight);
            three.renderer.setClearColor(0x000000, 0);
            three.renderer.shadowMap.enabled = true;
            three.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            ui.viewer.appendChild(three.renderer.domElement);
            
            three.labelRenderer = new CSS2DRenderer();
            three.labelRenderer.setSize(ui.viewer.clientWidth, ui.viewer.clientHeight);
            three.labelRenderer.domElement.style.position = 'absolute';
            three.labelRenderer.domElement.style.top = '0px';
            ui.labelsContainer.appendChild(three.labelRenderer.domElement);

            three.camera.position.set(0, 2000, 3500);
            
            three.controls = new OrbitControls(three.camera, three.renderer.domElement);
            three.controls.enableDamping = true;
            three.controls.dampingFactor = 0.05;
            three.controls.screenSpacePanning = false;
            three.controls.minDistance = 200;
            three.controls.maxDistance = 15000;
            three.controls.maxPolarAngle = Math.PI / 2.1;
            
            three.scene.add(new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(2000, 3000, 1500);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 4000; dirLight.shadow.camera.bottom = -4000;
            dirLight.shadow.camera.left = -4000; dirLight.shadow.camera.right = 4000;
            dirLight.shadow.camera.near = 100; dirLight.shadow.camera.far = 8000;
            three.scene.add(dirLight);

            three.scene.background = new THREE.Color(0x152238);

            const groundGeometry = new THREE.PlaneGeometry(50000, 50000, 250, 250);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x3d4a3d, roughness: 0.8, metalness: 0.2 });
            three.groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
            three.groundPlane.rotation.x = -Math.PI / 2;
            three.groundPlane.receiveShadow = true;
            three.scene.add(three.groundPlane);
            three.initialGroundVertices = new Float32Array(groundGeometry.attributes.position.array);
            
            const gridHelper = new THREE.GridHelper(20000, 100, 0xffffff, 0xffffff);
            gridHelper.material.opacity = 0.15;
            gridHelper.material.transparent = true;
            three.scene.add(gridHelper);
            
            trajectoryVisualsGroup = new THREE.Group();
            three.scene.add(trajectoryVisualsGroup);
            three.scene.add(three.gameGroup, three.effectsGroup, three.triangulationGroup, three.enemyTrajectoryGroup, three.labelsGroup);
        }

        function initMap() {
            map = L.map(ui.mapContainer, { zoomControl: false, attributionControl: false }).setView([49.212, 37.60], 13);
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' }).addTo(map);
            gameState.mapLayers.impacts.addTo(map);
        }

        function initGameLogic() {
            const observerPos = eventLogData.position.location;
            setSceneOrigin(observerPos.lat, observerPos.lon);
            gameState.playerPositions = {
                "P1 (Схід)": { name: "P1 (Схід)", lat: 49.215, lon: 37.285, hp: 100 },
                "P2 (Захід)": { name: "P2 (Захід)", lat: 49.213, lon: 37.255, hp: 100 },
                "P3 (Південь)": { name: "P3 (Південь)", lat: 49.208, lon: 37.270, hp: 100 }
            };
            Object.values(gameState.playerPositions).forEach(pos => {
                pos.coords = latLngToMeters(gameState.currentCoords, pos.lat, pos.lon);
                createUnitObject(pos, 'player');
            });
            setActivePosition('P1 (Схід)');
            updatePositionSelector();
        }

        function initEventListeners() {
            ui.simulateEnemyFireButton.addEventListener('click', simulateEnemyFire);
            ui.fireButton.addEventListener('click', fireShot);
            ui.locateAndWeatherButton.addEventListener('click', locateAndGetWeather);
            ui.resetDeformationButton.addEventListener('click', resetDeformation);
            ui.calculateTargetSolutionButton.addEventListener('click', calculateTargetSolution);
            [ui.chargeSelect, ui.angleInput, ui.hCorrectionInput, ui.trajectoryCheckbox, ui.chargeTempInput].forEach(el => el.addEventListener('change', () => {
                drawTrajectoryPreview();
                saveState();
            }));
            ui.showMapCheckbox.addEventListener('change', (e) => { ui.mapContainer.classList.toggle('visible', e.target.checked); saveState(); });
            ui.positionSelect.addEventListener('change', (e) => setActivePosition(e.target.value));
            ui.extraInfoButton.addEventListener('click', () => ui.modalOverlay.classList.add('visible'));
            ui.openCalibrationButton.addEventListener('click', () => ui.calibrationModalOverlay.classList.add('visible'));
            ui.openTriangulationButton.addEventListener('click', () => ui.triangulationModalOverlay.classList.add('visible'));
            
            document.querySelectorAll('.modal-close-button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const modal = e.target.closest('.modal-overlay');
                    modal.classList.remove('visible');
                    if (modal.id === 'enemy-report-modal-overlay') {
                        while(three.enemyTrajectoryGroup.children.length > 0) { three.enemyTrajectoryGroup.remove(three.enemyTrajectoryGroup.children[0]); }
                    }
                });
            });
            
            ui.addTriangulationRayButton.addEventListener('click', addTriangulationRay);
            ui.calculateIntersectionButton.addEventListener('click', calculateIntersection);
            ui.aimAtIntersectionButton.addEventListener('click', aimAtTriangulationResult);
            ui.calibrateKButton.addEventListener('click', calibrateK);
            ui.saveStateButton.addEventListener('click', () => { saveState(); logMessage('Стан збережено вручну.', 'system'); });
            ui.clearStateButton.addEventListener('click', clearState);
            ui.toggleUiButton.addEventListener('click', () => ui.uiPanel.classList.toggle('visible'));
            
            ui.viewer.addEventListener('dblclick', onDoubleClick);
            ui.viewer.addEventListener('mousemove', onMouseMove);
            ui.viewer.addEventListener('mouseleave', () => { ui.mouseCoordsDisplay.textContent = "Lat/Lon: ---"; });
        }
        
        function onDoubleClick(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const rect = ui.viewer.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, three.camera);
            const intersects = raycaster.intersectObject(three.groundPlane);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                logMessage(`Ціль по кліку: X=${point.x.toFixed(1)}, Z=${point.z.toFixed(1)}`, 'system');
                const { lat, lng } = metersToLatLng(gameState.currentCoords, point.x, point.z);
                aimAtCoordinates(lat, lng);
                const marker = new THREE.Mesh(new THREE.CylinderGeometry(20, 20, 2, 32), new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true }));
                marker.position.set(point.x, 1, point.z);
                three.effectsGroup.add(marker);
                gsap.to(marker.scale, { x: 3, z: 3, duration: 0.5 });
                gsap.to(marker.material, { opacity: 0, duration: 1.5, delay: 0.5, onComplete: () => three.effectsGroup.remove(marker) });
            }
        }

        function onMouseMove(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const rect = ui.viewer.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, three.camera);
            const intersects = raycaster.intersectObject(three.groundPlane);
            if (intersects.length > 0) {
                const point = intersects[0].point;
                const { lat, lng } = metersToLatLng(gameState.currentCoords, point.x, point.z);
                ui.mouseCoordsDisplay.textContent = `Lat: ${lat.toFixed(5)} / Lon: ${lng.toFixed(5)}`;
            }
        }

        function drawEnemyTrajectory(trajectory) {
             while(three.enemyTrajectoryGroup.children.length > 0) { three.enemyTrajectoryGroup.remove(three.enemyTrajectoryGroup.children[0]); }
            if (!trajectory || trajectory.length < 2) return;
            const curve = new THREE.CatmullRomCurve3(trajectory);
            const tube = new THREE.Mesh(new THREE.TubeGeometry(curve, trajectory.length, 5, 8, false), new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.8 }));
            three.enemyTrajectoryGroup.add(tube);
            const startPoint = trajectory[0].clone();
            const endPoint = trajectory[trajectory.length - 1].clone();
            startPoint.y = 1; endPoint.y = 1;
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]), new THREE.LineDashedMaterial({ color: 0xff8888, dashSize: 50, gapSize: 25 }));
            line.computeLineDistances();
            three.enemyTrajectoryGroup.add(line);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(three.controls) three.controls.update();
            const now = performance.now();
            const delta = (now - lastTime) / 1000;
            for (let i = activeExplosions.length - 1; i >= 0; i--) {
                const explosion = activeExplosions[i];
                explosion.elapsed += delta;
                if (explosion.elapsed > explosion.duration) {
                    three.effectsGroup.remove(explosion.group);
                    activeExplosions.splice(i, 1);
                } else {
                    const progress = explosion.elapsed / explosion.duration, easeOutQuad = t => t * (2 - t);
                    const scaleProgress = easeOutQuad(progress);
                    explosion.shockwave.scale.setScalar(1 + scaleProgress * 4);
                    explosion.shockwave.material.opacity = 1.0 - progress;
                    explosion.fireball.scale.setScalar(1 + scaleProgress * 2);
                    explosion.fireball.material.opacity = 1.0 - progress * progress;
                    if (explosion.flash.material.opacity > 0) explosion.flash.material.opacity -= delta * 5;
                }
            }
            frameCount++;
            if (now >= lastTime + 1000) {
                if(ui.fpsCounter) ui.fpsCounter.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
            }
            lastTime = now;
            three.renderer.render(three.scene, three.camera);
            if (three.labelRenderer) three.labelRenderer.render(three.scene, three.camera);
        }
        
        async function simulateEnemyFire() {
            const playerPosNames = Object.keys(gameState.playerPositions);
            if (playerPosNames.length < 3) { logMessage("Помилка: Потрібно мінімум 3 свої позиції для симуляції.", "error"); return; }
            const randomEvent = eventLogData.events[Math.floor(Math.random() * eventLogData.events.length)];
            logMessage(`СИМУЛЯЦІЯ: Використання даних події '${randomEvent.name}'...`, "system");
            const { lat, lon } = calculateCoordsFromAzimuthDistance(eventLogData.position.location.lat, eventLogData.position.location.lon, parseAzimuth(randomEvent.azimuth), parseFloat(randomEvent.distance));
            logMessage(`Розрахована позиція ворога: Lat ${lat.toFixed(5)}, Lon ${lon.toFixed(5)}`, "info");
            
            const enemyFirePoint = new THREE.Vector3(latLngToMeters(gameState.currentCoords, lat, lon).x, 0, latLngToMeters(gameState.currentCoords, lat, lon).z);
            const targetPlayerName = playerPosNames[Math.floor(Math.random() * playerPosNames.length)];
            const targetPlayer = gameState.playerPositions[targetPlayerName];
            logMessage(`Ворог веде вогонь по '${targetPlayerName}'!`, "warning");
            
            createExplosion(enemyFirePoint, 15);
            const solution = findFiringSolutionIterative(enemyFirePoint, targetPlayer.mesh.position);
            
            if (solution) {
                const params = { charge: solution.charge, angle: solution.angle, hCorrection: solution.azimuth, chargeTemp: 15 };
                const { trajectory, timeOfFlight, groundRange, arcLength, correctedVelocity } = calculateTrajectory(enemyFirePoint, params, false);
                if (trajectory) {
                    drawEnemyTrajectory(trajectory);
                    await animateShell(trajectory, 0xff0000);
                    createExplosion(targetPlayer.mesh.position, CONFIG.HIT_RADIUS, true);

                    // Populate Report
                    const launchLatLng = metersToLatLng(gameState.currentCoords, enemyFirePoint.x, enemyFirePoint.z);
                    const impactLatLng = metersToLatLng(gameState.currentCoords, targetPlayer.mesh.position.x, targetPlayer.mesh.position.z);
                    ui.reportLaunchCoords.textContent = `${launchLatLng.lat.toFixed(5)}, ${launchLatLng.lng.toFixed(5)}`;
                    ui.reportImpactCoords.textContent = `${impactLatLng.lat.toFixed(5)}, ${impactLatLng.lng.toFixed(5)}`;
                    ui.reportDirectDistance.textContent = `${groundRange.toFixed(0)} м`;
                    ui.reportBallisticRange.textContent = `${arcLength.toFixed(0)} м`;
                    ui.reportTof.textContent = `${timeOfFlight.toFixed(1)} с`;
                    ui.reportParamVelocity.textContent = `${correctedVelocity.toFixed(1)} м/с`;
                    ui.reportParamMass.textContent = `${MORTAR_TABLES['120mm_HE'].mass} кг`;
                    ui.reportParamGravity.textContent = `${CONFIG.GRAVITY} м/с²`;
                    ui.reportParamDensity.textContent = `${gameState.weather.airDensity.toFixed(3)} кг/м³`;
                    ui.reportParamWind.textContent = `${gameState.weather.windSpeed.toFixed(1)} м/с, ${gameState.weather.windDirection}°`;
                    ui.reportParamK.textContent = `${CONFIG.BALLISTIC_K.toFixed(3)}`;
                    ui.enemyReportModalOverlay.classList.add('visible');
                }
            } else { logMessage(`Не вдалося знайти рішення для симуляції пострілу ворога по ${targetPlayerName}.`, "warning"); }

            const observers = playerPosNames.filter(name => name !== targetPlayerName).slice(0, 2);
            logMessage("Спостерігачі фіксують азимути...", "system");
            gameState.triangulationRays = [];
            observers.forEach(observerName => {
                const observer = gameState.playerPositions[observerName];
                const vector = enemyFirePoint.clone().sub(observer.mesh.position);
                const calculatedAzimuth = (THREE.MathUtils.radToDeg(Math.atan2(vector.x, vector.z)) + 360) % 360;
                gameState.triangulationRays.push({ id: Date.now() + Math.random(), lat: observer.lat, lon: observer.lon, azimuth: calculatedAzimuth });
                logMessage(`> ${observerName} зафіксував азимут: ${calculatedAzimuth.toFixed(1)}°`, "info");
            });
            updateTriangulationVisuals();
            calculateIntersection();
            logMessage("Тріангуляцію виконано автоматично. Перевірте 3D-сцену.", "success");
            saveState();
        }
        
        function parseAzimuth(azimuthStr) {
            if (String(azimuthStr).includes('-')) { const [min, max] = String(azimuthStr).split('-').map(Number); return Math.random() * (max - min) + min; }
            return parseFloat(azimuthStr);
        }

        function calculateCoordsFromAzimuthDistance(lat, lon, azimuth, distanceMeters) {
            const R = 6378137; const d = distanceMeters; const brng = THREE.MathUtils.degToRad(azimuth);
            const lat1 = THREE.MathUtils.degToRad(lat); const lon1 = THREE.MathUtils.degToRad(lon);
            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d / R) + Math.cos(lat1) * Math.sin(d / R) * Math.cos(brng));
            let lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(d / R) * Math.cos(lat1), Math.cos(d / R) - Math.sin(lat1) * Math.sin(lat2));
            return { lat: THREE.MathUtils.radToDeg(lat2), lon: THREE.MathUtils.radToDeg(lon2) };
        }
        
        async function fireShot() {
            if (!gameState.activePlayerPositionName) return;
            const startPosObj = gameState.playerPositions[gameState.activePlayerPositionName];
            const params = { charge: ui.chargeSelect.value, angle: parseFloat(ui.angleInput.value), hCorrection: parseFloat(ui.hCorrectionInput.value), chargeTemp: parseFloat(ui.chargeTempInput.value) };
            if (gameState.mapLayers.trajectory) map.removeLayer(gameState.mapLayers.trajectory);
            const { trajectory, timeOfFlight, groundRange, arcLength } = calculateTrajectory(startPosObj.mesh.position, params);
            if (!trajectory || trajectory.length === 0) { logMessage("Помилка розрахунку траєкторії", "error"); return; }
            const latLngTrajectory = trajectory.map(p => { const latLng = metersToLatLng(gameState.currentCoords, p.x, p.z); return [latLng.lat, latLng.lng]; });
            gameState.mapLayers.trajectory = L.polyline(latLngTrajectory, { color: 'yellow', weight: 2, opacity: 0.8 }).addTo(map);
            await animateShell(trajectory);
            const impactPoint = trajectory[trajectory.length - 1];
            gameState.lastShot.startPoint = startPosObj.mesh.position.clone();
            gameState.lastShot.intendedEndPoint = impactPoint.clone();
            createExplosion(impactPoint, CONFIG.HIT_RADIUS, true);
            ui.impactInfoDisplay.innerHTML = `Дальність: ${arcLength.toFixed(0)}м<br>Час: ${timeOfFlight.toFixed(1)}с`;
            gameState.lastImpactPointForInfo = impactPoint.clone();
            setTimeout(() => { ui.impactInfoDisplay.style.display = 'none'; gameState.lastImpactPointForInfo = null; }, 6000);
            const impactLatLng = metersToLatLng(gameState.currentCoords, impactPoint.x, impactPoint.z);
            L.circle([impactLatLng.lat, impactLatLng.lng], { radius: CONFIG.HIT_RADIUS, color: 'red', fillOpacity: 0.3 }).addTo(gameState.mapLayers.impacts);
            logMessage(`Снаряд впав. Час польоту: ${timeOfFlight.toFixed(1)}с, дальність: ${groundRange.toFixed(0)}м.`, "system");
            ui.openCalibrationButton.disabled = false;
        }
        
        function calibrateK() {
             const impactLat = parseFloat(ui.impactLatInput.value); const impactLon = parseFloat(ui.impactLonInput.value);
             if (isNaN(impactLat) || isNaN(impactLon) || !gameState.lastShot.startPoint) { logMessage("Введіть коректні координати або зробіть постріл.", "error"); return; }
             const actualImpactCoords = latLngToMeters(gameState.currentCoords, impactLat, impactLon);
             const actualImpactPoint = new THREE.Vector3(actualImpactCoords.x, 0, actualImpactCoords.z);
             const intendedRange = gameState.lastShot.startPoint.distanceTo(gameState.lastShot.intendedEndPoint);
             const actualRange = gameState.lastShot.startPoint.distanceTo(actualImpactPoint);
             if (intendedRange < 1) { logMessage("Помилка: розрахункова дальність занадто мала.", "error"); return; }
             const kCorrection = (actualRange * actualRange) / (intendedRange * intendedRange);
             CONFIG.BALLISTIC_K *= kCorrection;
             ui.kDisplay.textContent = `k: ${CONFIG.BALLISTIC_K.toFixed(3)}`;
             logMessage(`Коефіцієнт 'k' скориговано на ${kCorrection.toFixed(3)}. Нове значення: ${CONFIG.BALLISTIC_K.toFixed(3)}`, "success");
             saveState(); ui.calibrationModalOverlay.classList.remove('visible');
        }
        
        function calculateTrajectory(startPos, params, updateHUD = true) {
            const munition = MORTAR_TABLES['120mm_HE'];
            const { angle, charge, hCorrection, chargeTemp } = params;
            const verticalAngleRad = THREE.MathUtils.degToRad(angle); const hCorrectionRad = THREE.MathUtils.degToRad(hCorrection);
            const baseVelocity = munition.charges[charge];
            const tempDiff = chargeTemp - CONFIG.STANDARD_TEMP_C;
            const correctedVelocity = baseVelocity * (1 + tempDiff * CONFIG.TEMP_VELOCITY_COEFFICIENT) * Math.sqrt(CONFIG.BALLISTIC_K);
            let pos = startPos.clone();
            let vel = new THREE.Vector3( correctedVelocity * Math.cos(verticalAngleRad) * Math.sin(hCorrectionRad), correctedVelocity * Math.sin(verticalAngleRad), correctedVelocity * Math.cos(verticalAngleRad) * Math.cos(hCorrectionRad) );
            const windVel = new THREE.Vector3( gameState.weather.windSpeed * Math.sin(THREE.MathUtils.degToRad(gameState.weather.windDirection)), 0, gameState.weather.windSpeed * Math.cos(THREE.MathUtils.degToRad(gameState.weather.windDirection)) );
            const trajectoryPoints = [startPos.clone()]; const dt = 0.05; let timeOfFlight = 0;
            const crossSectionalArea = Math.PI * (munition.caliber / 2) ** 2;
            while(pos.y >= 0) {
                const relativeVel = vel.clone().sub(windVel); const speed = relativeVel.length();
                const dragForceMagnitude = 0.5 * gameState.weather.airDensity * speed * speed * crossSectionalArea * munition.Cd;
                const dragForce = relativeVel.clone().normalize().multiplyScalar(-dragForceMagnitude);
                const gravityForce = new THREE.Vector3(0, -CONFIG.GRAVITY * munition.mass, 0);
                const totalForce = dragForce.add(gravityForce); const acceleration = totalForce.divideScalar(munition.mass);
                vel.add(acceleration.clone().multiplyScalar(dt)); pos.add(vel.clone().multiplyScalar(dt));
                trajectoryPoints.push(pos.clone()); timeOfFlight += dt;
                if (timeOfFlight > 300) { logMessage("Перевищено час польоту, розрахунок зупинено.", "error"); break; }
            }
            if (trajectoryPoints.length > 1) {
                const lastPoint = trajectoryPoints[trajectoryPoints.length-2]; const currentPoint = trajectoryPoints[trajectoryPoints.length-1];
                const t = lastPoint.y / (lastPoint.y - currentPoint.y); const finalPos = lastPoint.clone().lerp(currentPoint, t);
                finalPos.y = 0; trajectoryPoints[trajectoryPoints.length-1] = finalPos;
            }
            if (trajectoryPoints.length < 2) return {};
            const groundRange = startPos.distanceTo(trajectoryPoints[trajectoryPoints.length-1]);
            let arcLength = 0; for(let i = 1; i < trajectoryPoints.length; i++) { arcLength += trajectoryPoints[i].distanceTo(trajectoryPoints[i-1]); }
            if (updateHUD) {
                ui.tofDisplay.textContent = `ToF: ${timeOfFlight.toFixed(1)}с`;
                ui.rangeHudDisplay.textContent = `Дальність: ${arcLength.toFixed(0)}м`;
                ui.directRangeHudDisplay.textContent = `Пряма: ${groundRange.toFixed(0)}м`;
            }
            return { trajectory: trajectoryPoints, timeOfFlight, groundRange, arcLength, correctedVelocity };
        }
        
        function drawTrajectoryPreview() {
            while (trajectoryVisualsGroup.children.length > 0) { trajectoryVisualsGroup.remove(trajectoryVisualsGroup.children[0]); }
            while(three.labelsGroup.children.length > 0) { three.labelsGroup.remove(three.labelsGroup.children[0]); }
            if (!ui.trajectoryCheckbox.checked || !gameState.activePlayerPositionName) {
                 ui.tofDisplay.textContent = `ToF: ---`; ui.rangeHudDisplay.textContent = `Дальність: ---`; ui.directRangeHudDisplay.textContent = `Пряма: ---`;
                 return;
            }
            const startPosObj = gameState.playerPositions[gameState.activePlayerPositionName];
            const params = { charge: ui.chargeSelect.value, angle: parseFloat(ui.angleInput.value), hCorrection: parseFloat(ui.hCorrectionInput.value), chargeTemp: parseFloat(ui.chargeTempInput.value) };
            const { trajectory, timeOfFlight, groundRange, arcLength } = calculateTrajectory(startPosObj.mesh.position, params, true);
            if (!trajectory || trajectory.length < 2) return;
            const curve = new THREE.CatmullRomCurve3(trajectory);
            const tube = new THREE.Mesh(new THREE.TubeGeometry(curve, trajectory.length, 5, 8, false), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 }));
            trajectoryVisualsGroup.add(tube);
            const startPoint = trajectory[0].clone(); const endPoint = trajectory[trajectory.length - 1].clone();
            startPoint.y = 1; endPoint.y = 1;
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]), new THREE.LineDashedMaterial({ color: 0x00aaff, dashSize: 50, gapSize: 25 }));
            line.computeLineDistances();
            trajectoryVisualsGroup.add(line);
            const groundMidpoint = new THREE.Vector3().lerpVectors(startPoint, endPoint, 0.5);
            const groundLabelDiv = document.createElement('div');
            groundLabelDiv.className = 'trajectory-label';
            groundLabelDiv.textContent = `Пряма: ${groundRange.toFixed(0)}м / ${timeOfFlight.toFixed(1)}с`;
            const groundLabel = new CSS2DObject(groundLabelDiv);
            groundLabel.position.copy(groundMidpoint);
            three.labelsGroup.add(groundLabel);
            let apexPoint = startPoint; trajectory.forEach(p => { if(p.y > apexPoint.y) apexPoint = p; });
            const apexLabelDiv = document.createElement('div');
            apexLabelDiv.className = 'trajectory-label';
            apexLabelDiv.textContent = `Дуга: ${arcLength.toFixed(0)}м`;
            const apexLabel = new CSS2DObject(apexLabelDiv);
            apexLabel.position.copy(apexPoint);
            three.labelsGroup.add(apexLabel);
        }
        
        function calculateTargetSolution() {
            const lat = parseFloat(ui.targetLatInput.value); const lon = parseFloat(ui.targetLonInput.value);
            if (isNaN(lat) || isNaN(lon)) { logMessage("Введіть коректні координати цілі.", "error"); return; }
            aimAtCoordinates(lat, lon);
        }

        function aimAtCoordinates(lat, lon) {
            if (!gameState.activePlayerPositionName) { logMessage("Спочатку виберіть позицію для стрільби.", "error"); return; }
            const startPos = gameState.playerPositions[gameState.activePlayerPositionName].mesh.position;
            const targetCoords = latLngToMeters(gameState.currentCoords, lat, lon);
            const targetPos = new THREE.Vector3(targetCoords.x, 0, targetCoords.z);
            logMessage("Розрахунок рішення...", "system");
            setTimeout(() => {
                const solution = findFiringSolutionIterative(startPos, targetPos);
                if (solution) {
                    ui.chargeSelect.value = solution.charge; ui.angleInput.value = solution.angle.toFixed(1); ui.hCorrectionInput.value = solution.azimuth.toFixed(1);
                    logMessage(`Рішення для цілі: Дальність ${solution.distance}м, Азимут ${solution.azimuth.toFixed(1)}°, Заряд №${solution.charge}, Кут ${solution.angle.toFixed(1)}°`, "info");
                    drawTrajectoryPreview(); ui.targetLatInput.value = lat.toFixed(5); ui.targetLonInput.value = lon.toFixed(5);
                } else { logMessage("Не вдалося знайти рішення для враження цілі.", "error"); }
            }, 100);
        }
        
        // --- MODIFIED: Smarter AI charge selection ---
        function findFiringSolutionIterative(fromPoint, toPoint) {
            const distance = fromPoint.distanceTo(toPoint);
            const vector = toPoint.clone().sub(fromPoint);
            const azimuth = (THREE.MathUtils.radToDeg(Math.atan2(vector.x, vector.z)) + 360) % 360;
            const chargeTemp = parseFloat(ui.chargeTempInput.value);
            
            let possibleSolutions = [];

            for (const charge of Object.keys(MORTAR_TABLES['120mm_HE'].charges)) {
                let bestAngleForCharge = -1;
                let minDiff = Infinity;
                
                for (let angle = 45; angle <= 85; angle += 0.5) {
                    const params = { charge, angle, hCorrection: azimuth, chargeTemp };
                    const { groundRange } = calculateTrajectory(fromPoint, params, false);
                    const diff = Math.abs(groundRange - distance);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestAngleForCharge = angle;
                    }
                }
                
                if (minDiff < 50) { // Tolerance for a valid solution
                    possibleSolutions.push({
                        charge,
                        angle: bestAngleForCharge,
                        optimality: Math.abs(bestAngleForCharge - 60) // Closer to 60 is better
                    });
                }
            }

            if (possibleSolutions.length === 0) return null;

            possibleSolutions.sort((a, b) => a.optimality - b.optimality);
            const bestSolution = possibleSolutions[0];

            return { distance: distance.toFixed(0), azimuth, charge: bestSolution.charge, angle: bestSolution.angle };
        }

        function metersToLatLng(origin, x, z) {
            const latRad = origin.lat * Math.PI / 180;
            return { lat: origin.lat + (z / 111132), lng: origin.lon + (x / (111320 * Math.cos(latRad))) };
        }
        
        function latLngToMeters(origin, lat, lon) {
            const latRadOrigin = origin.lat * Math.PI / 180;
            return { x: (lon - origin.lon) * (111320 * Math.cos(latRadOrigin)), z: (lat - origin.lat) * 111132 };
        }

        function setSceneOrigin(lat, lon) {
            gameState.currentCoords = { lat, lon };
            if (map) {
                map.setView([lat, lon], 13);
                if (gameState.originMarker) map.removeLayer(gameState.originMarker);
                gameState.originMarker = L.marker([lat, lon]).addTo(map).bindPopup("Центр сцени (0,0)").openPopup();
            }
        }

        function createUnitObject(pos, type) {
            const color = type === 'player' ? 0x00aaff : 0xff2a2a;
            const group = new THREE.Group();
            const base = new THREE.Mesh( new THREE.CylinderGeometry(20, 20, 5, 16), new THREE.MeshStandardMaterial({ color: color, roughness: 0.7, metalness: 0.4 }) );
            base.castShadow = true;
            group.add(base); group.position.set(pos.coords.x, 2.5, pos.coords.z); group.name = pos.name;
            three.gameGroup.add(group); pos.mesh = group;
        }

        function animateShell(trajectory, color = 0xffff00) {
            return new Promise(resolve => {
                const shell = new THREE.Mesh(new THREE.SphereGeometry(25, 12, 12), new THREE.MeshBasicMaterial({ color }));
                three.effectsGroup.add(shell);
                let i = 0;
                function step() {
                    if (i < trajectory.length) { shell.position.copy(trajectory[i]); i++; requestAnimationFrame(step); } 
                    else { three.effectsGroup.remove(shell); resolve(); }
                }
                step();
            });
        }
        
        function createExplosion(position, radius = CONFIG.HIT_RADIUS, deformGround = false) {
            const group = new THREE.Group(); group.position.copy(position);
            const flash = new THREE.Mesh( new THREE.SphereGeometry(radius * 0.5, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 }) );
            const fireball = new THREE.Mesh( new THREE.SphereGeometry(radius * 0.8, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.8 }) );
            const shockwave = new THREE.Mesh( new THREE.SphereGeometry(radius, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, side: THREE.BackSide }) );
            group.add(flash, fireball, shockwave); three.effectsGroup.add(group);
            activeExplosions.push({ group, flash, fireball, shockwave, elapsed: 0, duration: 1.5 });
            
            if (deformGround) {
                const groundGeometry = three.groundPlane.geometry;
                const positions = groundGeometry.attributes.position;
                const explosionRadius = radius * 2.0; const maxDepth = radius * 0.5;
                for (let i = 0; i < positions.count; i++) {
                    const vertex = new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i));
                    const distance = Math.sqrt(Math.pow(vertex.x - position.x, 2) + Math.pow(vertex.z - position.z, 2));
                    if (distance < explosionRadius) {
                        const displacement = maxDepth * (1 - (distance / explosionRadius)) * (Math.cos(distance / explosionRadius * Math.PI) * 0.5 + 0.5);
                        positions.setY(i, vertex.y - displacement);
                    }
                }
                positions.needsUpdate = true; groundGeometry.computeVertexNormals();
            }
        }
        
        function resetDeformation() {
            const groundGeometry = three.groundPlane.geometry;
            groundGeometry.attributes.position.array.set(three.initialGroundVertices);
            groundGeometry.attributes.position.needsUpdate = true;
            groundGeometry.computeVertexNormals();
            logMessage("Деформацію ландшафту скинуто.", "system");
        }

        function locateAndGetWeather() {
            if (!navigator.geolocation) { logMessage("GPS не підтримується цим браузером.", "error"); return; }
            logMessage("Запит вашої позиції GPS...", "system");
            navigator.geolocation.getCurrentPosition( async (position) => {
                const { latitude, longitude } = position.coords;
                logMessage(`Ваша позиція: ${latitude.toFixed(5)}, ${longitude.toFixed(5)}`, "success");
                if (gameState.gpsMarker.three) three.scene.remove(gameState.gpsMarker.three);
                if (gameState.gpsMarker.map) map.removeLayer(gameState.gpsMarker.map);
                const myCoords = latLngToMeters(gameState.currentCoords, latitude, longitude);
                const marker = new THREE.Mesh(new THREE.ConeGeometry(30, 100, 16), new THREE.MeshBasicMaterial({ color: 0x00aaff }));
                marker.position.set(myCoords.x, 50, myCoords.z);
                three.scene.add(marker); gameState.gpsMarker.three = marker;
                gameState.gpsMarker.map = L.marker([latitude, longitude]).addTo(map).bindPopup("Моя позиція").openPopup();
                map.setView([latitude, longitude], 14);
                logMessage("Запит даних про погоду...", "system");
                try {
                    const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,wind_speed_10m,wind_direction_10m`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    gameState.weather.tempC = data.current.temperature_2m;
                    gameState.weather.windSpeed = data.current.wind_speed_10m;
                    gameState.weather.windDirection = data.current.wind_direction_10m;
                    gameState.weather.airDensity = 101325 / (287.05 * (data.current.temperature_2m + 273.15));
                    updateWeatherDisplays(); logMessage("Дані про погоду успішно оновлено.", "success"); saveState();
                } catch (error) { logMessage(`Помилка завантаження погоди: ${error.message}`, "error"); }
            }, () => { logMessage("Не вдалося отримати GPS координати.", "error"); });
        }

        function updateWeatherDisplays() {
            ui.temperatureDisplay.textContent = `${gameState.weather.tempC.toFixed(1)} °C`;
            ui.airDensityDisplay.textContent = `${gameState.weather.airDensity.toFixed(3)} кг/м³`;
            ui.windDisplay.textContent = `${gameState.weather.windSpeed.toFixed(1)} м/с (${gameState.weather.windDirection.toFixed(0)}°)`;
        }

        function logMessage(msg, type = "info") {
            const color = { system: 'cyan', info: 'lightgreen', warning: 'orange', error: 'red', success: 'lime' }[type];
            console.log(`%c[${type.toUpperCase()}] ${msg}`, `color: ${color};`);
        }

        function onWindowResize() { 
            const viewer = ui.viewer; if (!viewer) return;
            const { clientWidth: w, clientHeight: h } = viewer; if (!w || !h) return;
            three.camera.aspect = w / h; 
            three.camera.updateProjectionMatrix(); 
            three.renderer.setSize(w, h);
            if(three.labelRenderer) three.labelRenderer.setSize(w, h);
        }

        function setActivePosition(name) { 
            gameState.activePlayerPositionName = name; 
            if (ui.positionSelect.value !== name) { ui.positionSelect.value = name; }
            drawTrajectoryPreview();
        }
        
        function updatePositionSelector() { 
            if(!ui.positionSelect) return;
            ui.positionSelect.innerHTML = Object.keys(gameState.playerPositions).map(name => `<option value="${name}" ${name === gameState.activePlayerPositionName ? 'selected' : ''}>${name}</option>`).join('');
        }
        
        function addTriangulationRay() {
             const lat = parseFloat(ui.rayLatInput.value); const lon = parseFloat(ui.rayLonInput.value); const azimuth = parseFloat(ui.rayAzimuthInput.value);
             if (isNaN(lat) || isNaN(lon) || isNaN(azimuth)) return;
             const ray = { id: Date.now(), lat, lon, azimuth };
             gameState.triangulationRays.push(ray); updateTriangulationVisuals(); saveState();
             ui.calculateIntersectionButton.disabled = gameState.triangulationRays.length < 2;
        }
        
        function removeTriangulationRay(id) {
            gameState.triangulationRays = gameState.triangulationRays.filter(ray => ray.id !== id);
            updateTriangulationVisuals(); saveState();
            ui.calculateIntersectionButton.disabled = gameState.triangulationRays.length < 2;
            ui.aimAtIntersectionButton.disabled = true; gameState.lastTriangulationResult = null;
        }
        
         function calculateIntersection() {
             if (gameState.triangulationRays.length < 2) return;
             const A = [], b = [];
             gameState.triangulationRays.forEach(ray => {
                 const origin = latLngToMeters(gameState.currentCoords, ray.lat, ray.lon);
                 const azRad = THREE.MathUtils.degToRad(ray.azimuth);
                 const normalX = Math.cos(azRad), normalZ = -Math.sin(azRad);
                 A.push([normalX, normalZ]); b.push(normalX * origin.x + normalZ * origin.z);
             });
             try {
                 const At = numeric.transpose(A), AtA = numeric.dot(At, A), Atb = numeric.dot(At, b);
                 const AtA_inv = numeric.inv(AtA), intersection = numeric.dot(AtA_inv, Atb);
                 const [x, z] = intersection;
                 if (triangulationIntersectionMarker) three.triangulationGroup.remove(triangulationIntersectionMarker);
                 const marker = new THREE.Mesh(new THREE.SphereGeometry(30, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                 marker.position.set(x, 10, z); three.triangulationGroup.add(marker);
                 triangulationIntersectionMarker = marker;
                 const {lat, lng} = metersToLatLng(gameState.currentCoords, x, z);
                 logMessage(`Перетин знайдено: Lat ${lat.toFixed(5)}, Lon ${lng.toFixed(5)}`, "success");
                 gameState.lastTriangulationResult = { lat, lon: lng }; ui.aimAtIntersectionButton.disabled = false;
             } catch (error) {
                 logMessage("Не вдалося знайти перетин. Можливо, промені паралельні.", "error");
                 gameState.lastTriangulationResult = null; ui.aimAtIntersectionButton.disabled = true;
             }
         }

        function updateTriangulationVisuals() {
            while(three.triangulationGroup.children.length > 0) three.triangulationGroup.remove(three.triangulationGroup.children[0]);
            triangulationIntersectionMarker = null;
            ui.triangulationRaysList.innerHTML = '';
            gameState.triangulationRays.forEach(ray => {
                const originCoords = latLngToMeters(gameState.currentCoords, ray.lat, ray.lon);
                const originVec = new THREE.Vector3(originCoords.x, 1, originCoords.z);
                const li = document.createElement('li'); li.className = 'triangulation-ray-item';
                li.innerHTML = `<span>${ray.lat.toFixed(3)}, ${ray.lon.toFixed(3)} @ ${ray.azimuth.toFixed(1)}°</span><button data-id="${ray.id}">X</button>`;
                li.querySelector('button').addEventListener('click', (e) => removeTriangulationRay(parseFloat(e.target.dataset.id)));
                ui.triangulationRaysList.appendChild(li);
                const azimuthRad = THREE.MathUtils.degToRad(ray.azimuth);
                const endPoint = new THREE.Vector3(originVec.x + 20000 * Math.sin(azimuthRad), 1, originVec.z + 20000 * Math.cos(azimuthRad));
                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([originVec, endPoint]), new THREE.LineBasicMaterial({color: 0xff8800}));
                three.triangulationGroup.add(line);
            });
            ui.calculateIntersectionButton.disabled = gameState.triangulationRays.length < 2;
        }

        function aimAtTriangulationResult() {
            if (gameState.lastTriangulationResult) {
                aimAtCoordinates(gameState.lastTriangulationResult.lat, gameState.lastTriangulationResult.lon);
                ui.triangulationModalOverlay.classList.remove('visible');
            } else { logMessage("Немає розрахованого перетину для наведення.", "error"); }
        }
        
        function saveState() {
            const stateToSave = {
                ballisticK: CONFIG.BALLISTIC_K,
                triangulationRays: gameState.triangulationRays.map(({id, lat, lon, azimuth}) => ({id, lat, lon, azimuth})),
                ui: { trajectory: ui.trajectoryCheckbox.checked, map: ui.showMapCheckbox.checked },
                weather: gameState.weather,
                chargeTemp: ui.chargeTempInput.value,
            };
            localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(stateToSave));
        }

        function loadState() {
            const savedStateJSON = localStorage.getItem(CONFIG.STORAGE_KEY);
            if (!savedStateJSON) { logMessage("Збережений стан не знайдено.", "system"); return; }
            try {
                const savedState = JSON.parse(savedStateJSON);
                CONFIG.BALLISTIC_K = savedState.ballisticK || 1.0;
                gameState.triangulationRays = savedState.triangulationRays || [];
                if (savedState.ui) {
                    ui.trajectoryCheckbox.checked = savedState.ui.trajectory ?? true;
                    ui.showMapCheckbox.checked = savedState.ui.map ?? false;
                    ui.mapContainer.classList.toggle('visible', ui.showMapCheckbox.checked);
                }
                if (savedState.weather) gameState.weather = savedState.weather;
                if (savedState.chargeTemp) ui.chargeTempInput.value = savedState.chargeTemp;
                ui.kDisplay.textContent = `k: ${CONFIG.BALLISTIC_K.toFixed(3)}`;
                updateTriangulationVisuals();
                updateWeatherDisplays();
                logMessage("Попередній стан успішно завантажено.", "success");
            } catch (e) {
                logMessage("Помилка завантаження стану. Дані можуть бути пошкоджені.", "error");
                clearState();
            }
        }

        function clearState() {
            localStorage.removeItem(CONFIG.STORAGE_KEY);
            logMessage("Збережений стан очищено.", "system");
            window.location.reload();
        }

        init();
    </script>
</body>
                           </html>
